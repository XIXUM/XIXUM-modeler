/*
 * generated by Xtext 2.16.0
 */
package org.xixum.modeler.spelling.ui.quickfix

import org.xixum.modeler.spelling.ui.editor.model.NlxDocument
import java.util.List
import org.eclipse.jface.text.IDocumentListener
import org.eclipse.ui.texteditor.MarkerAnnotation
import org.eclipse.xtext.ui.editor.model.IXtextDocument
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.ui.editor.quickfix.XtextResourceMarkerAnnotationModel
import org.eclipse.xtext.ui.editor.validation.XtextAnnotation
import org.eclipse.xtext.validation.Issue
import org.xixum.modeler.spelling.constants.NaturalLangConstants

import org.xixum.utils.data.util.ClassUtil

import static org.xixum.modeler.spelling.ui.constants.EditorUiConstants._NLX_CAP_IMAGE_URL
import static org.xixum.modeler.spelling.ui.constants.EditorUiConstants._NLX_DATA_KEY
import static org.xixum.modeler.spelling.ui.constants.EditorUiConstants._NLX_INFO_ANNOTATION_TYPE
import static org.xixum.modeler.spelling.ui.constants.EditorUiConstants._UI_CAPITALIZE_NAME
import static org.xixum.modeler.spelling.ui.constants.EditorUiConstants._UI_CAPITALIZE_THE_NAME



/**
 * Custom quickfixes.
 * 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
class NaturalLangQuickfixProvider extends DefaultQuickfixProvider {

	

	/**
	 * Goes through al Xtext markers and removes the trained Word
	 */
	def updateMarkers(IXtextDocument document, Issue issue, String word) {
		if (document instanceof NlxDocument) {
			val List<IDocumentListener> ListenerList = document.getDocumentListeners()
			for (listener : ListenerList) {
				var model = ClassUtil.getOuterClassInstOfAnonymous(listener)
				if (model instanceof XtextResourceMarkerAnnotationModel) {
					var iterator2 = model.annotationIterator
					while (iterator2.hasNext) {
						var elm = iterator2.next
						if (elm instanceof XtextAnnotation) {
							var iss = (elm as XtextAnnotation).issue
							if (iss.data !== null && !iss.data.isEmpty && iss.data.get(0).toLowerCase.equals(issue.data.get(0).toLowerCase)) { //TODO: 05.10.21 causes Null-Pointer do a Null check
								elm.markDeleted(true)    
								model.fireAnnotationChangedEvent(elm)
							}														//TODO: 20.02.22 scroll restore. cursor is getting refreshed to top after this 
						}
						if (elm instanceof MarkerAnnotation && elm.type.equals(_NLX_INFO_ANNOTATION_TYPE)) {
							var marker = (elm as MarkerAnnotation).marker
							var attributes = marker.attributes
							var name = (attributes.get(_NLX_DATA_KEY) as String).split(':')
							if (name.size == 2 && name.get(1).equals(word)) {
								elm.markDeleted(true)
								//model.queueAnnotationChanged(elm)
								model.fireAnnotationChangedEvent(elm)
							}
						}
					}
					//model.updateMarkers(document)
				}
			}
		}
	}

@Fix(NaturalLangConstants._TYPO_)
	def capitalizeName(Issue issue, IssueResolutionAcceptor acceptor) {
		// val name = xtextDocument.get(issue.offset, issue.length)
		acceptor.accept(issue, _UI_CAPITALIZE_NAME, _UI_CAPITALIZE_THE_NAME, _NLX_CAP_IMAGE_URL) [ context |
			val xtextDocument = context.xtextDocument
			val firstLetter = xtextDocument.get(issue.offset, 1)
			xtextDocument.replace(issue.offset, 1, firstLetter.toUpperCase)
		]
	}

}
